from abc import ABCMeta, abstractmethod
import datetime
import queue
import win32com.client
import pythoncom

from ebest_event import FillEvent, OrderEvent

class ExecutionHandler(object):
    """
    The ExecutionHandler abstract class hadles the interaction between
    a set of Order objects generated by a Portfolio and ultimate set of
    Fill objects that actually occur in the market.

    The handler can be used to subclass simulated brokerages or live brokerages,
    with identical interface. This allow strategies to be backtested in very similar
    manner to the live trading engine
    """

    __metaclass__ = ABCMeta

    @abstractmethod
    def execute_order(self, event):
        """
        Takes an Order event and executes it, producing a Fill event that
        gets placed onto the Events queue.
        :param event: Contains an Event object with order information
        :return:
        """
        raise NotImplementedError("Should implement execute_order()")


class SimulatedExecutionHandler(ExecutionHandler):
    """
    The simulated execution handler simply converts all order objects into
    their equivalent fill objects automatically without latency, slippage or fill-ratio issues.

    This allow a straightforward "first-go" test of any strategy,
    before implementation with a more sophisticated execution handler.
    """
    def __init__(self, events):
        """
        Initialises the handler, setting the event queues up internally.
        :param events: The Queue of Event objects.
        """
        self.events = events

    def execute_order(self, event): #Naive Version 실질적으로는 Slippage 고려 필요. 호가잔량 정보 반영시켜보자.
        """
        Simply converts Order objects into Fill object naively,
        i.e. without latency, slippage or fill ratio problems.

        :param event: Contains an Event object with order information.
        :return:
        """
        if event.type == "ORDER":
            fill_event = FillEvent(datetime.datetime.utcnow(),
                                   event.symbol,
                                   'BT',
                                   event.quantity, event.direction, None, event.est_fill_cost)
            #Fill Cost as None when Backtest(Portfolio 에서 계산해줌)
            #Live Trading에서는 HTS 매입단가 넣어주면됨.
            #order type도 반영안됨. 그냥 Close로 계산.
            self.events.put(fill_event)

class MyObjects:
    server = "demo"  # hts:실투자, demo: 모의투자
    credentials = pd.read_csv("./credentials/credentials.csv", index_col=0, dtype=str).loc[server, :]

    login_ok = False  # Login
    tr_ok = False  # TR요청
    real_ok = False  # 실시간 요청
    acc_no_stock = credentials["acc_no_stocks"]  # 주식 계좌번호
    acc_no_future = credentials["acc_no_futures"]  # 주식선물 계좌번호
    acc_pw = credentials["acc_pw"]  # 계좌비밀번호

    acc_balance = {}

    tr_event = None  # TR요청에 대한 API 정보
    t0424_request = None # TR: 잔고 함수
    CSPAT00600_request = None # TR: 주문 함수


# 실시간으로 수신받는 데이터를 다루는 구간
class XR_event_handler:

    def OnReceiveRealData(self, code):

        if code == "SC0":
            ordno = self.GetFieldData("OutBlock", "ordno")  # 주문번호
            shtcode = self.GetFieldData("OutBlock", "shtcode")  # 종목코드 7자리
            ordtm = self.GetFieldData("OutBlock", "ordtm")  # 주문시간
            ordqty = self.GetFieldData("OutBlock", "ordqty")  # 주문수량
            ordgb = self.GetFieldData("OutBlock", "ordgb") # 주문구분(01: 현금매도, 02: 현금매수, 03: 신용매도, 04: 신용매수)
            # ordamt = self.GetFieldData("OutBlock", "ordamt")  # 주문금액
            # ordablemny = self.GetFieldData("OutBlock", "ordablemny")  # 주문가능현금
            print("주문접수 SC0, 주문시간: %s, 주문번호: %s, 주문수량: %s, 주문구분: %s, 종목코드: %s" % (ordtm, ordno, ordqty, ordgb, shtcode), flush=True)

        elif code == "SC1":
            ordno = self.GetFieldData("OutBlock", "ordno")  # 주문번호
            execqty = self.GetFieldData("OutBlock", "execqty")  # 체결수량
            execprc = self.GetFieldData("OutBlock", "execprc")  # 체결가격
            shtcode = self.GetFieldData("OutBlock", "shtcode")  # 종목코드 7자리 ??? 잇나?
            isuno = self.GetFieldData("OutBlock", "isuno") # 종목번호 형태모름...
            print(isuno)
            exectime = self.GetFieldData("OutBlock", "exectime")  # 체결시간
            mnyexecamt = self.GetFieldData("OutBlock", "mnyexecamt")  # 현금체결금액 (신용체결금액도 있음) # 나중에 써보기
            bnstp = self.GetFieldData("OutBlock", "bnstp") # 매매구분 (1:매도 , 2: 매수) , 주문구분이 체결에는 없는듯..?
            print("주문체결 SC1, 체결시간: %s, 주문번호: %s, 체결수량: %s, 체결가격: %s, 종목코드: %s" % (exectime, ordno, execqty, execprc, shtcode), flush=True)

            shtcode = shtcode[1:]
            fill_cost = execqty * execprc
            direction = None
            if bnstp == "1":
                direction = "SELL"
            elif bnstp == "2":
                direction = "BUY"

            fill_event = FillEvent(datetime.datetime.utcnow(),
                                   shtcode,
                                   'REAL',
                                   execqty, direction, fill_cost, None) #, event.est_fill_cost) 슬리피지 계산위해 고려해보기?
            self.events.put(fill_event)
            ## 내일 와서 잘엮기!

# TR 요청 이후 수신결과 데이터를 다루는 구간
class XQ_event_handler:

    def OnReceiveData(self, code):
        print("%s 수신" % code, flush=True)

        # TR: 잔고 조회
        if code == "t0424":
            cts_expcode = self.GetFieldData("t0424OutBlock", "cts_expcode", 0)
            occurs_count = self.GetBlockCount("t0424OutBlock1")

            for i in range(occurs_count):
                expcode = self.GetFieldData("t0424OutBlock1", "expcode", i)

                if expcode not in MyObjects.acc_balance.keys():
                    MyObjects.acc_balance[expcode] = {}

                tt = MyObjects.t0424_dict[expcode]
                tt["잔고수량"] = int(self.GetFieldData("t0424OutBlock1", "janqty", i))
                tt["매도가능수량"] = int(self.GetFieldData("t0424OutBlock1", "mdposqt", i))
                tt["평균단가"] = int(self.GetFieldData("t0424OutBlock1", "pamt", i))
                tt["종목명"] = self.GetFieldData("t0424OutBlock1", "hname", i)
                tt["종목구분"] = self.GetFieldData("t0424OutBlock1", "jonggb", i)
                tt["수익률"] = float(self.GetFieldData("t0424OutBlock1", "sunikrt", i))

            print("잔고내역 %s" % MyObjects.acc_balance, flush=True)

            if self.IsNext is True: # 과거 데이터가 더 존재한다.
                MyObjects.t0424_request(cts_expcode=cts_expcode, next=self.IsNext)
            elif self.IsNext is False:
                print("Total 잔고내역 %s" % MyObjects.acc_balance, flush=True)
                # 잔고 많이 만들어서 확인해보기?!
                MyObjects.tr_ok = True


    def OnReceiveMessage(self, systemError, messageCode, message):
        print("systemError: %s, messageCode: %s, message: %s" % (systemError, messageCode, message), flush=True)


# 서버접속 및 로그인 요청 이후 수신결과 데이터를 다루는 구간
class XS_event_handler:

    def OnLogin(self, szCode, szMsg):
        print("%s %s" % (szCode, szMsg), flush=True)
        if szCode == "0000":
            MyObjects.login_ok = True
        else:
            MyObjects.login_ok = False


# 실행용 클래스
class Exec:
    def __init__(self):
        print("실행용 클래스이다")

        #로그인
        session = win32com.client.DispatchWithEvents("XA_Session.XASession", XS_event_handler)
        session.ConnectServer(MyObjects.server + ".ebestsec.co.kr", 20001)  # 서버 연결
        session.Login(MyObjects.credentials["ID"], MyObjects.credentials["PW"], MyObjects.credentials["gonin_PW"], 0,
                      False)  # 서버 연결

        while MyObjects.login_ok is False:
            pythoncom.PumpWaitingMessages()

        # 잔고: TR
        MyObjects.tr_event.ResFileName = "C:/eBEST/xingAPI/Res/t0424.res"
        MyObjects.t0424_request = self.t0424_request
        MyObjects.acc_balance = {}
        MyObjects.t0424_request(cts_expcode="", next=False)

        # 주식 주문: TR
        MyObjects.CSPAT00600_event = win32com.client.DispatchWithEvents("XA_DataSet.XAQuery", XQ_event_handler)
        MyObjects.CSPAT00600_event.ResFileName = "C:/eBEST/xingAPI/Res/CSPAT00600.res"
        MyObjects.CSPAT00600_request = self.CSPAT00600_request

        # 주식 주문접수: Real
        MyObjects.SC0_event = win32com.client.DispatchWithEvents("XA_DataSet.XAReal", XR_event_handler)
        MyObjects.SC0_event.ResFileName = "C:/eBEST/xingAPI/Res/SC0.res"
        MyObjects.SC0_event.AdviseRealData()

        # 주식 체결: Real
        MyObjects.SC1_event = win32com.client.DispatchWithEvents("XA_DataSet.XAReal", XR_event_handler)
        MyObjects.SC1_event.ResFileName = "C:/eBEST/xingAPI/Res/SC1.res"
        MyObjects.SC1_event.AdviseRealData()

        while MyObjects.real_ok is False:
            pythoncom.PumpWaitingMessages()

    def t0424_request(self, cts_expcode=None, next=None):
        # TR: 주식선물 종목코드 가져오기
        MyObjects.tr_event = win32com.client.DispatchWithEvents("XA_DataSet.XAQuery", XQ_event_handler)

        MyObjects.tr_event.ResFileName = "C:/eBEST/xingAPI/Res/t0424.res"
        MyObjects.tr_event.SetFieldData("t0424InBlock", "accno", 0, MyObjects.acc_no_stock)
        MyObjects.tr_event.SetFieldData("t0424InBlock", "passwd", 0, MyObjects.acc_pw)
        MyObjects.tr_event.SetFieldData("t0424InBlock", "prcgb", 0, "1")
        MyObjects.tr_event.SetFieldData("t0424InBlock", "chegb", 0, "2")
        MyObjects.tr_event.SetFieldData("t0424InBlock", "dangb", 0, "0")
        MyObjects.tr_event.SetFieldData("t0424InBlock", "charge", 0, "0")  # 제비용 포함여부 0: 미포함, 1: 포함
        MyObjects.tr_event.SetFieldData("t0424InBlock", "cts_expcode", 0, "")

        MyObjects.tr_event.Request(next)

        MyObjects.tr_ok = False
        while MyObjects.tr_ok is False:
            pythoncom.PumpWaitingMessages()

    def CSPAT00600_request(self, order_type, AcntNo=None, InptPwd=None, IsuNo=None, OrdQty=0, BnsTpCode=None):
        MyObjects.CSPAT00600_event.SetFieldData("CSPAT00600InBlock1", "AcntNo", 0, AcntNo)  # 계좌번호
        MyObjects.CSPAT00600_event.SetFieldData("CSPAT00600InBlock1", "InptPwd", 0, InptPwd)  # 비밀번호

        if MyObjects.server == "demo":
            IsuNo = "A" + IsuNo

        ot = None
        if order_type == "MKT":
            ot = "03"
        elif order_type == "LMT":
            ot = "00"
        else:
            print("put correct order type! MKT or LMT")

        MyObjects.CSPAT00600_event.SetFieldData("CSPAT00600InBlock1", "IsuNo", 0, IsuNo)  # 종목번호
        MyObjects.CSPAT00600_event.SetFieldData("CSPAT00600InBlock1", "OrdQty", 0, OrdQty)  # 주문수량
        MyObjects.CSPAT00600_event.SetFieldData("CSPAT00600InBlock1", "OrdPrc", 0, 0)  # 주문가
        MyObjects.CSPAT00600_event.SetFieldData("CSPAT00600InBlock1", "BnsTpCode", 0, BnsTpCode)  # 1:매도, 2:매수
        MyObjects.CSPAT00600_event.SetFieldData("CSPAT00600InBlock1", "OrdprcPtnCode", 0, ot)  # 호가유형코드, 03:시장가
        MyObjects.CSPAT00600_event.SetFieldData("CSPAT00600InBlock1", "MgntrnCode", 0, "000")  # 신용거래코드, 000:보통
        MyObjects.CSPAT00600_event.SetFieldData("CSPAT00600InBlock1", "LoanDt", 0, "")  # 대출일
        MyObjects.CSPAT00600_event.SetFieldData("CSPAT00600InBlock1", "OrdCndiTpCode", 0,
                                                "0")  # 주문조건구분 0:없음, 1:IOC, 2:FOK

        err = MyObjects.CSPAT00600_event.Request(False)
        if err < 0:
            print("\nXXXXXXXXXXXXXXX "
                  "\nCSPAT00600 주문에러"
                  "\n계좌번호: %s"
                  "\n종목코드: %s"
                  "\n주문수량: %s"
                  "\n매매구분: %s"
                  "\n주문에러: %s"
                  "\n\n" % (AcntNo, IsuNo, OrdQty, BnsTpCode, err), flush=True)

        else:
            print("\n============="
                  "\nCSPAT00600 주문 실행"
                  "\n계좌번호: %s"
                  "\n종목코드: %s"
                  "\n주문수량: %s"
                  "\n매매구분: %s"
                  "\n주문에러: %s"
                  "\n\n" % (AcntNo, IsuNo, OrdQty, BnsTpCode, err), flush=True)

class EbestExecutionHandler(ExecutionHandler):
    """
    Key moving parts should be msg from API. We send orders and receive fill msg from API,
    thus using msgs we can implement various Execution Optimization Logic.
    """
    def __init__(self, events):
        self.events = events
        Exec() # Order 넣으면 Fill은 알아서 나감.

    def execute_order(self, event):
        """
        Simply converts Order objects into Fill object naively,
        i.e. without latency, slippage or fill ratio problems.

        :param event: Contains an Event object with order information.
        :return:
        """
        if event.type == "ORDER":
            direction = None
            if event.direction == "BUY":
                direction = "2"
            elif event.direction == "SELL":
                direction = "1"
            else:
                print("put right direction: BUY or SELL")

            MyObjects.CSPAT00600_request(orderevent.order_type, AcntNo=MyObjects.acc_no_stock, InptPwd=MyObjects.acc_pw, IsuNo=event.symbol,
                                         OrdQty=event.quantity, BnsTpCode=direction)